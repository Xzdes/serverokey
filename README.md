# Serverokey 🚀 v3.0

**Serverokey** (Сервер-окей) — это атомарный, декларативный движок для бэкенда на Node.js, спроектированный для создания веб-приложений с помощью LLM (Large Language Models). Его главная задача — превратить LLM из "программиста" в "архитектора", который описывает **ЧТО** нужно сделать, а не **КАК**.

*   **Автор:** Xzdes
*   **Контакт:** [xzdes@yandex.ru](mailto:xzdes@yandex.ru)
*   **Репозиторий:** [https://github.com/Xzdes/serverokey](https://github.com/Xzdes/serverokey)

---

## 🎯 Философия: Архитектура вместо Кода

Современные LLM отлично генерируют код, но часто ошибаются в деталях, требующих контекста. Serverokey решает эту проблему, заменяя написание императивного кода на заполнение декларативных структур в центральном файле — `manifest.js`.

1.  **Декларативные Действия:** Вместо JS-кода для добавления товара в корзину, LLM описывает операцию: `{"operation": "push", "target": "receipt.items", ...}`.
2.  **Вычисляемые Данные:** Вместо JS-кода для пересчета суммы заказа, LLM описывает ее как формулу: `{"target": "total", "formula": "sum(items, 'price')"}`.
3.  **Декларативная Логика:** Вместо `if/else` в JS, LLM описывает условные шаги прямо в манифесте: `{"if": "receipt.total > 300", "then": [...]}`.
4.  **Полная Изоляция:** Движок сам находит файлы, обновляет DOM, управляет состоянием и обеспечивает безопасность. LLM не имеет прямого доступа к файловой системе или рендерингу.

> **Результат:** LLM работает с **единой точкой входа** (`manifest.js`) и генерирует предсказуемые, безопасные и легко проверяемые веб-приложения.

---

## 🎨 Архитектура в деталях

Весь рабочий процесс построен вокруг центрального манифеста (`manifest.js`), который является "мозгом" приложения.

### 1. Структура проекта

Движок диктует строгую и понятную структуру. LLM работает только внутри папки `app`.

```
/my-project
  ├── kassa-app/                <-- Папка вашего приложения
  │   ├── manifest.js           <-- ⭐️ Единственный файл, который определяет ВСЮ логику
  │   └── app/
  │       ├── actions/          <-- (Запасной вариант) Сложная императивная JS-логика
  │       ├── components/       <-- HTML-шаблоны и их CSS-стили
  │       ├── data/             <-- JSON-файлы с данными (состояние)
  │       └── operations/       <-- (Опционально) Кастомные, переиспользуемые операции
  │
  ├── core/                     <-- Ядро движка (не трогаем)
  ├── engine.js                 <-- Точка входа сервера (не трогаем)
  ├── engine-client.js          <-- Клиентский скрипт (не трогаем)
  └── validate-manifest.js      <-- ⭐️ Валидатор для проверки manifest.js
```

### 2. Поток данных: от клика до обновления

Движок работает по принципу "HTML-over-the-wire", но с умным обновлением DOM и выполнением сложной логики на сервере.

```ascii
                                                       ┌──────────────────┐
                                                       │   manifest.js    │
 ╔═════════╗       ╔════════════════╗      ┌───────────┬──>│ (route: 'action' │
 ║ Browser ║──────>║ engine-client.js ║ POST->║ RequestHandler  ├─>│   'steps')       │ 1.
 ╚═════════╝       ╚════════════════╝      └─────┬─────┬───┘  └──────────────────┘
   (Клик)                                      │     │
                                               │     │ 2. Создание контекста
                                               │     └──────────┐
                                               │      ┌─────────▼─────────┐
                                               └─────>│    ActionEngine     │
                                             3. Вызов  └─────────┬─────────┘
                                                движка           │ 4. Выполнение шагов
                                                                 │ (if, forEach, http:get)
                                                       ┌─────────▼─────────┐
 ╔═════════╗       ╔════════════════╗      ┌───────────┐│   DataManager     │
 ║ Browser ║<──────║ engine-client.js ║<─────┤ HTML-фрагмент ├─+──>│ (с FormulaParser) │
 ╚═════════╝       ╚════════════════╝ HTML  └───────────┘ │ 9. │ └─────────┬─────────┘
   9. Умное                              (ответ)         │    │           │ 6. Вычисление
   обновление                                            │    │              (computed)
   DOM                                                   │    │           ┌─────────▼─────────┐
                                                         │    └───────────┤  Сохранение в JSON  │
                                                         │                ╚═══════════════════╝
                                                         │ 7. Рендеринг обновленного
                                                         │    компонента (Renderer)
                                                         └─────────────────┘
```

---

## 🛠️ Рабочий процесс

### 1. Установка

Клонируйте репозиторий. **Serverokey** не требует `npm install` или других зависимостей.
```bash
git clone https://github.com/Xzdes/serverokey.git
cd serverokey
```

### 2. Валидация (Критически важный шаг!)

Перед запуском или после внесения изменений в `manifest.js`, всегда запускайте валидатор. Он проверит ваш манифест на сотни потенциальных ошибок и даст понятные подсказки.
```bash
node validate-manifest.js
```
**Успешный результат:** `✅ [Validator] Manifest validation successful. No issues found.`
**Результат с ошибками:** Подробный отчет с указанием проблемы и файла.

### 3. Запуск сервера

```bash
node engine.js
```
Сервер запустится на `http://localhost:3000`.

---

## 💡 Справочник по `manifest.js`

`manifest.js` — это единый источник правды для всего приложения.

### `globals`
Опциональная секция для определения данных, доступных во всех компонентах.

```javascript
globals: {
  appName: "Мое Приложение",
  // Делает источник данных 'user' доступным глобально во всех шаблонах
  injectData: ['user'] 
}
```

### `data`
Описывает источники данных, их начальное состояние и вычисляемые поля.

```javascript
data: {
  receipt: {
    initialState: { items: [], total: '0.00', discountPercent: 0 },
    // Поля, которые вычисляются автоматически при каждом изменении `receipt`
    computed: [
      {
        "target": "total",                // Какое поле вычислить
        "formula": "sum(items, 'price')", // Как его вычислить (встроенная функция)
        "format": "toFixed(2)"            // Как отформатировать
      },
      {
        "target": "discount",
        // Формула может использовать другие поля, включая вычисляемые
        "formula": "total * (discountPercent / 100)" 
      }
    ]
  }
}
```

### `components`
Регистрирует компоненты и их стили. Стили автоматически изолируются (scoped).
```javascript
components: {
  // Простой синтаксис
  mainLayout: 'main-layout.html',
  // Расширенный синтаксис со стилями
  receipt: {
    template: 'receipt.html',   // Шаблон компонента
    style: 'receipt.css'        // Связанный файл стилей
  }
}
```

### `routes`
Связывает URL с действиями (`view` или `action`).

#### `type: 'view'`
Отвечает за рендеринг целой страницы.
```javascript
'GET /': {
  type: 'view',
  layout: 'mainLayout', // Какой компонент использовать как основной макет
  inject: {
    // В какой <atom-inject> какой компонент вставить
    'receipt': 'receipt',
    'positionsList': 'positionsList'
  }
}
```

#### `type: 'action'`
Выполняет серверную логику и возвращает обновленный HTML-фрагмент. Имеет три взаимоисключающих способа определения логики (приоритет: `steps` > `manipulate` > `handler`).

1.  **`handler` (Запасной вариант):** Ссылка на JS-файл для сложной императивной логики.
    `"handler": "filterPositions"` -> `app/actions/filterPositions.js`

2.  **`manipulate` (Для простых CRUD):** Декларативное описание одной операции.
    ```javascript
    "manipulate": {
      "operation": "push", // или "removeFirstWhere", или "custom:myOperation"
      "target": "receipt.items",
      // ... другие параметры
    }
    ```

3.  **`steps` (Рекомендуемый и самый мощный способ):** Массив последовательных шагов для выполнения сложной логики без написания JS.
    ```javascript
    'POST /action/applyBonus': {
      type: 'action',
      steps: [
        // 1. Условный блок (IF / THEN / ELSE)
        {
          "if": "receipt.total > 300 && !receipt.bonusApplied",
          "then": [
            { "set": "receipt.discountPercent", "to": "receipt.discountPercent + 5" },
            { "set": "receipt.bonusApplied", "to": "true" }
          ],
          "else": [ /* ... */ ]
        },
        // 2. HTTP-запрос (HTTP:GET)
        {
          "http:get": {
            "url": "'http://numbersapi.com/' + receipt.itemCount",
            "saveTo": "context.fact" // Сохраняем результат во временную переменную
          }
        },
        // 3. Цикл (FOREACH)
        {
          "forEach": "receipt.items",
          "as": "item", // Имя переменной для элемента
          "steps": [
            { "if": "item.price > 100", "then": [{ "set": "item.isExpensive", "to": "true" }] }
          ]
        }
      ],
      reads: ['receipt'],
      writes: ['receipt'],
      update: 'receipt'
    }
    ```

---

## 템 Шаблоны и Директивы

Движок использует **Mustache.js** для рендеринга (`{{variable}}`, `{{#array}}...`). В дополнение, Serverokey предоставляет свои директивы и хелперы.

### Условный рендеринг: `atom-if`
Атрибут, который полностью удаляет элемент из DOM, если условие ложно.
```html
<!-- Этот блок будет показан, только если в массиве есть элементы -->
<ul atom-if="receipt.items.length > 0">
    ...
</ul>

<!-- Этот блок будет показан, только если массив пуст -->
<div atom-if="!receipt.items.length">
    Чек пуст
</div>
```

### Клиентские скрипты: `<script atom-run>`
"Предохранительный клапан" для случаев, когда необходим JavaScript на клиенте (например, для интеграции со сторонней библиотекой графиков).

**Пример в `my-component.html`:**
```html
<div>
  <!-- ID контейнера должен быть уникальным. Используем внутреннюю переменную. -->
  <div id="chart-{{_internal.id}}"></div>

  <!-- Этот скрипт выполнится на клиенте после рендера/обновления компонента -->
  <script atom-run>
    // `this` указывает на корневой элемент компонента (<div>)
    const container = this.querySelector('#chart-{{_internal.id}}');
    
    // Безопасная передача данных с сервера с помощью хелпера asJSON
    const data = {{{ asJSON(chartData.values) }}};

    // Вызов внешней библиотеки, которая должна быть подключена на странице
    renderMyCoolChart(container, data);
  </script>
</div>
```

---

## 🔮 Будущие улучшения

*   [ ] **Декларативные WebSocket'ы:** Описание каналов и событий для real-time обновлений.
*   [ ] **Встроенная аутентификация:** Декларативные маршруты для регистрации/логина.
*   [ ] **Горячая перезагрузка (Hot-reloading):** Автоматический перезапуск сервера при изменении `manifest.js`.
*   [ ] **Расширение `ActionEngine`:** Добавление новых типов шагов (`try/catch`, `switch`, `http:post`).

---

Этот проект — эксперимент в области взаимодействия человека и машины, направленный на создание надежных и предсказуемых программных систем. Буду рад вашим идеям и вкладу!

**Xzdes**