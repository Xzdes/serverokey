# Serverokey 🚀

**Serverokey** (Сервер-окей) — это атомарный, декларативный движок для бэкенда на Node.js, спроектированный для создания веб-приложений с помощью LLM (Large Language Models). Его главная задача — превратить LLM из "программиста" в "архитектора", который описывает **ЧТО** нужно сделать, а не **КАК**.

*   **Автор:** Xzdes
*   **Контакт:** [xzdes@yandex.ru](mailto:xzdes@yandex.ru)
*   **Репозиторий:** [https://github.com/Xzdes/serverokey](https://github.com/Xzdes/serverokey)

---

## 🎯 Философия: Архитектура вместо Кода

Современные LLM отлично генерируют код, но часто ошибаются в деталях, требующих контекста. Serverokey решает эту проблему, заменяя написание императивного кода на заполнение декларативных структур в центральном файле — `manifest.js`.

1.  **Декларативные Действия:** Вместо JS-кода для добавления товара в корзину, LLM описывает операцию: `{"operation": "push", "target": "receipt.items", ...}`.
2.  **Вычисляемые Данные:** Вместо JS-кода для пересчета суммы заказа, LLM описывает ее как формулу: `{"target": "total", "formula": "sum(items, 'price')"}`.
3.  **Декларативная Видимость:** Вместо логики в шаблонах, LLM управляет отображением через HTML-атрибут: `atom-if="receipt.items.length > 0"`.
4.  **Полная Изоляция:** Движок сам находит файлы, обновляет DOM, управляет состоянием и обеспечивает безопасность. LLM не имеет прямого доступа к файловой системе или рендерингу.

> **Результат:** LLM работает с **единой точкой входа** (`manifest.js`) и генерирует предсказуемые, безопасные и легко проверяемые веб-приложения.

---

## 🎨 Архитектура в деталях

Весь рабочий процесс построен вокруг центрального манифеста, который является "мозгом" приложения.

### 1. Структура проекта

Движок диктует строгую и понятную структуру. LLM работает только внутри папки `app`.

```
/my-project
  ├── kassa-app/                <-- Папка вашего приложения
  │   ├── manifest.js           <-- ⭐️ Единственный файл, который определяет ВСЮ логику
  │   └── app/
  │       ├── actions/          <-- (Опционально) Сложная JS-логика
  │       ├── components/       <-- HTML-шаблоны и их CSS-стили
  │       └── data/             <-- JSON-файлы с данными (состояние)
  │
  ├── core/                     <-- Ядро движка (не трогаем)
  ├── engine.js                 <-- Точка входа сервера (не трогаем)
  └── engine-client.js          <-- Клиентский скрипт (не трогаем)
```

### 2. Поток данных и рендеринга

Движок работает по принципу "HTML-over-the-wire", но с "умным" обновлением DOM на клиенте для сохранения фокуса и состояния.

#### Полная загрузка страницы (`GET /`)

```ascii
                                            ┌──────────────────┐
                                            │   manifest.js    │
                                            │  (route: 'view') │
                                            └─────────┬────────┘
                                                      │ 1. Анализ маршрута
 ╔═════════╗       ╔════════════════╗       ┌─────────▼────────┐      ╔════════════════╗
 ║ Browser ║──────>║  RequestHandler  ║─────>║     Renderer     ║─────>║   app/components   ║
 ╚═════════╝  GET  ╚════════════════╝       │ (с Mustache.js)  │<─+──>║   app/data         ║
             /                              └─────────┬────────┘  │    ╚════════════════╝
                                                      │ 2. Рендеринг  │ 3. Загрузка ассетов
                                            ┌─────────▼────────┐    │ (AssetLoader)
                                            │ Готовый HTML+CSS │<───+
                                            └─────────┬────────┘
                                                      │ 4. Ответ клиенту
                                            ┌─────────▼────────┐
 ╔═════════╗       ╔════════════════╗       │   HTTP Response  │
 ║ Browser ║<──────║  RequestHandler  ║<──────┤ (HTML страница)  │
 ╚═════════╝       ╚════════════════╝       └──────────────────┘
```

#### Обработка Декларативного Действия (`POST /action/...`)

```ascii
                                                             ┌──────────────────┐
                                                             │   manifest.js    │
 ╔═════════╗       ╔════════════════╗       ┌───────────┬───>│(route: 'action', │
 ║ Browser ║──────>║ engine-client.js ║ POST->║ RequestHandler  ├─>│  'manipulate')   │ 1.
 ╚═════════╝       ╚════════════════╝       └─────┬─────┬───┘  └──────────────────┘
   (Клик)                                        │     │
                                                 │     │ 2. Создание контекста
                                                 │     └──────────┐
                                                 │      ┌─────────▼─────────┐
                                                 └─────>│   DataManipulator │
                                               3. Вызов  └─────────┬─────────┘
                                                  манипулятора     │ 4. Изменение данных
                                                                   │    в контексте
                                                         ┌─────────▼─────────┐
 ╔═════════╗       ╔════════════════╗       ┌───────────┐│   DataManager     │
 ║ Browser ║<──────║ engine-client.js ║<──────┤ HTML-фрагмент ├─+──>│ (с FormulaParser) │
 ╚═════════╝       ╚════════════════╝  HTML   └───────────┘ │ 8. │ └─────────┬─────────┘
   8. Умное                              (ответ)          │    │           │ 5. Вычисление
   обновление                                             │    │              (computed)
   DOM                                                    │    │           ┌─────────▼─────────┐
                                                          │    └───────────┤  Сохранение в JSON  │
                                                          │                ╚═══════════════════╝
                                                          │ 6. Рендеринг обновленного
                                                          │    компонента (Renderer)
                                                          └─────────────────┘
```

---

## 🛠️ Как это использовать

### 1. Установка и Запуск

Клонируйте репозиторий. **Serverokey** не требует `npm install`.
```bash
git clone https://github.com/Xzdes/serverokey.git && cd serverokey
node engine.js
```
Сервер запустится на `http://localhost:3000`.

### 2. Рабочий процесс для LLM (Декларативный путь)

**Задача:** "Добавь возможность удалять товары из чека по одному."

LLM больше не пишет JS-код. Она только редактирует `manifest.js` и `receipt.html`.

**Шаг 1: Описание действия в `manifest.js`**

LLM описывает операцию удаления в секции `routes`, используя `manipulate`:

```javascript
// manifest.js
// ...
'POST /action/removeItem': {
  type: 'action',
  // Никакого handler или JS-файла!
  manipulate: {
    target: 'receipt.items',          // Где меняем: в массиве receipt.items
    operation: 'removeFirstWhere',    // Что делаем: удаляем первый совпавший
    match: { "id": "body.itemId" }    // Как ищем: где id элемента равен itemId из тела запроса
  },
  reads: ['receipt'],
  writes: ['receipt'],
  update: 'receipt'
}
// ...
```

**Шаг 2: Добавление триггера в `app/components/receipt.html`**

LLM добавляет кнопку удаления. Она знает, что для удаления по `id` нужно передать `itemId`.

```html
<!-- app/components/receipt.html -->
<ul>
  {{#receipt.items}}
    <li>
      {{name}} - {{price}} руб.
      <button
        atom-action="POST /action/removeItem"
        atom-target="#receipt-container"
        name="itemId"
        value="{{id}}"
      >
        &times;
      </button>
    </li>
  {{/receipt.items}}
</ul>
```

**Результат:** Задача решена **без единой строчки императивного JS-кода**. LLM описала намерение, а движок его выполнил. Это быстрее, безопаснее и полностью соответствует философии Serverokey.

---

## 💡 Ключевые концепции API в `manifest.js`

### `globals`
Опциональная секция для определения данных, доступных во всех компонентах.

```javascript
globals: {
  appName: "Мое Приложение",
  // Делает источник данных 'user' доступным глобально
  injectData: ['user'] 
}
```

### `data`
Описывает источники данных и их вычисляемые поля.

```javascript
data: {
  receipt: {
    initialState: { items: [], total: '0.00' },
    // Поля, которые вычисляются автоматически при каждом изменении `receipt`
    computed: [
      {
        "target": "total",                // Какое поле вычислить
        "formula": "sum(items, 'price')", // Как его вычислить (встроенная функция)
        "format": "toFixed(2)"            // Как отформатировать
      },
      {
        "target": "discount",
        "formula": "total * 0.10" // Простое математическое выражение
      }
    ]
  }
}
```

### `components`
Описывает компоненты и их стили.
```javascript
components: {
  mainLayout: 'main-layout.html', // Простой шаблон
  receipt: {
    template: 'receipt.html',   // Шаблон компонента
    style: 'receipt.css'        // Связанный файл стилей
  }
}
```

### `routes`
Связывает URL с действиями.
*   `type: 'view'`: Рендеринг полной HTML-страницы.
*   `type: 'action'`: Выполнение серверной логики.
    *   `manipulate`: **(Предпочтительно)** Декларативное описание операции с данными (`push`, `removeFirstWhere`).
    *   `handler`: **(Опционально)** Имя JS-файла для сложной, нешаблонной логики.
    *   `reads`/`writes`: Какие "куски" данных изолировать для этого действия.
    *   `update`: Какой компонент перерисовать и отправить клиенту.

---

## 템 Шаблоны и Директивы

Движок использует **Mustache.js** для рендеринга, поэтому LLM может использовать весь стандартный синтаксис:
*   `{{variable}}` - Вставка переменной.
*   `{{#array}}...{{/array}}` - Итерация по массиву.
*   `{{#variable}}...{{/variable}}` - Секция "if".
*   `{{^variable}}...{{/variable}}` - Секция "else" (unless).

В дополнение, Serverokey предоставляет директиву `atom-if` для управления видимостью элементов.

```html
<!-- Этот блок будет показан, только если в массиве receipt.items есть элементы -->
<ul atom-if="receipt.items.length > 0">
    ...
</ul>

<!-- Этот блок будет показан, только если в массиве receipt.items НЕТ элементов -->
<div atom-if="!receipt.items.length">
    Чек пуст
</div>
```

---

## 🔮 Будущие улучшения

*   [ ] **Валидатор Манифеста:** Отдельный скрипт (`node validate.js`) для проверки `manifest.js` на логические ошибки.
*   [ ] **Декларативные HTTP-запросы:** Возможность для `action` декларативно выполнять GET/POST запросы к внешним API.
*   [ ] **Горячая перезагрузка (Hot-reloading):** Автоматический перезапуск сервера при изменении `manifest.js` или компонентов.
*   [ ] **Расширение `FormulaParser`:** Добавление новых встроенных функций (`average`, `find`, etc.) для еще более мощных вычислений.

---

Этот проект — эксперимент в области взаимодействия человека и машины, направленный на создание надежных и предсказуемых программных систем. Буду рад вашим идеям и вкладу!

**Xzdes**