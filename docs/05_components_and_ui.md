# 5. Создание Интерфейса: Компоненты и Шаблоны

Пользовательский интерфейс в Serverokey строится на основе концепции **компонентов**. Это независимые, переиспользуемые блоки, состоящие из HTML-шаблона и, опционально, изолированных CSS-стилей. Такой подход позволяет создавать сложные интерфейсы из простых "строительных кирпичиков".

## 1. Регистрация Компонентов

Прежде чем использовать компонент, его необходимо "объявить" в секции `components` файла `manifest.js`. Движок должен знать о существовании каждого компонента.

Все пути к файлам компонентов указываются относительно директории `app/components/`.

**Примеры регистрации:**

```javascript
// manifest.js
components: {
  // 1. Простой компонент: только HTML-шаблон.
  // 'mainLayout' - это имя, которое мы будем использовать в роутах.
  // 'main-layout.html' - это имя файла в `app/components/`.
  mainLayout: 'main-layout.html',

  // 2. Компонент с шаблоном и стилями.
  receipt: {
    template: 'receipt.html', // Путь к файлу шаблона
    style: 'receipt.css'      // Путь к файлу стилей
  },
  
  // 3. Компонент-обертка для страницы аутентификации
  authLayout: 'auth-layout.html'
}
```

## 2. Шаблонизатор Mustache.js

Для рендеринга HTML и вставки динамических данных Serverokey использует **Mustache.js**. Это простой, но мощный "logic-less" (безлогический) шаблонизатор. Его главная особенность — он не позволяет выполнять сложный код внутри HTML, что делает шаблоны безопасными и легко читаемыми.

### Вывод Переменных
Для вставки значения переменной из контекста данных используются двойные фигурные скобки `{{ ... }}`. Движок по умолчанию экранирует все HTML-теги внутри переменной для предотвращения XSS-атак.

**Доступ к данным:** Напоминаем, что все данные из коннекторов доступны через объект `data`, глобальные переменные — через `globals`, а информация о пользователе — через `user`.

```html
<!-- Отображение имени приложения из globals -->
<h1>{{globals.appName}}</h1>

<!-- Отображение имени пользователя -->
<p>Кассир: {{user.name}}</p>

<!-- Отображение поля из коннектора -->
<p>Итого к оплате: {{data.receipt.finalTotal}} руб.</p>
```

### Условное Отображение (Секции)
Mustache не имеет `if-else` в привычном понимании. Вместо этого он использует **секции**.

*   **`{{#имя_переменной}}...{{/имя_переменной}}`**: Содержимое этого блока будет отображено только в том случае, если `имя_переменной` имеет "истинное" значение (т.е. не является `false`, `null`, `undefined`, `0`, пустой строкой или пустым массивом `[]`).

*   **`{{^имя_переменной}}...{{/имя_переменной}}`**: Инвертированная секция. Содержимое будет отображено, если `имя_переменной` имеет "ложное" значение.

**Пример:**
```html
{{#data.receipt.items}}
  <!-- Этот ul будет показан, только если массив items не пустой -->
  <ul>
    ...
  </ul>
{{/data.receipt.items}}

{{^data.receipt.items}}
  <!-- Этот div будет показан, только если массив items пустой -->
  <div class="empty-state">Чек пуст</div>
{{/data.receipt.items}}
```

### Циклы по Массивам
Циклы — это естественное применение секций. Если переменная, на которую указывает секция, является массивом, то блок будет повторен для **каждого элемента** этого массива. Внутри блока можно обращаться к свойствам текущего элемента напрямую.

**Пример:**
```html
<ul>
  <!-- Для каждого элемента в массиве data.positions.items... -->
  {{#data.positions.items}}
    <!-- ...будет создан этот li. `name` и `price` - это свойства элемента. -->
    <li>{{name}} ({{price}} руб.)</li>
  {{/data.positions.items}}
</ul>
```

## 3. "Атомарные" Атрибуты Serverokey

Движок расширяет стандартный HTML набором специальных `atom-*` атрибутов, которые оживляют интерфейс.

*   **`atom-action="METHOD /url"`**
    Главный атрибут для взаимодействия. Он указывает, какой `action`-роут на сервере нужно вызвать.
    *   Пример: `atom-action="POST /action/addItem"`

*   **`atom-target="#css-selector"`**
    Указывает, какой элемент на странице нужно обновить, когда `action` вернет новый HTML. Значением должен быть уникальный CSS-селектор (обычно `id`).
    *   Пример: `atom-target="#receipt-container"`

*   **`atom-event="событие"`** (Опционально)
    Указывает, по какому DOM-событию должен сработать `atom-action`.
    *   **По умолчанию:** `click` для большинства элементов (кнопки, ссылки) и `submit` для тега `<form>`.
    *   **Часто используемое значение:** `input` для полей ввода, чтобы экшен срабатывал при каждом вводе символа (например, для "живого" поиска).
    *   Пример: `atom-event="input"`

*   **`atom-link="spa"`**
    Превращает обычную ссылку `<a>` в ссылку для одностраничного приложения (SPA). Вместо полной перезагрузки страницы, клиентский движок перехватит клик, запросит у сервера только нужный контент и обновит основную часть страницы.
    *   Пример: `<a href="/register" atom-link="spa">Перейти к регистрации</a>`

**Полный пример интерактивного элемента:**
```html
<input 
  type="text" 
  name="query"
  atom-action="POST /action/filterPositions" 
  atom-target="#positionsList-container"
  atom-event="input"
>
```

## 4. Директива `atom-if` для Серверного Рендеринга

Это мощная директива, которая выполняется **на сервере** до отправки HTML клиенту. Если JavaScript-выражение в атрибуте возвращает `false`, то сам элемент и все его дочерние элементы будут **полностью вырезаны** из HTML.

Это полезно для контроля доступа или отображения блоков в зависимости от состояния данных.

```html
<!-- Этот блок увидят только админы -->
<div atom-if="user.role === 'admin'">
  <a href="/admin-panel">Панель администратора</a>
</div>

<!-- Показать сообщение об ошибке, если она есть в URL -->
<p class="error" atom-if="url.query.error">Неверный логин или пароль.</p>
```

## 5. Изолированные Стили (Scoped CSS)

Когда вы подключаете файл стилей к компоненту в `manifest.js`, Serverokey автоматически делает эти стили **изолированными**. Каждый компонент при рендеринге получает уникальный атрибут `data-component-id="c-xxxxxx"`, и все CSS-правила из его файла стилей модифицируются так, чтобы применяться только внутри этого атрибута.

Это решает глобальную проблему CSS — конфликт имен классов. Стили одного компонента никогда не "сломают" стили другого.

Для стилизации самого корневого элемента компонента (того, на котором будет `data-component-id`), используйте специальный псевдоселектор `:host`.

**Пример (`receipt.css`):**
```css
/* Стили для корневого div компонента receipt */
:host {
  background-color: white;
  border-radius: 12px;
  padding: 20px;
}

/* Этот стиль применится только к h3 внутри компонента receipt */
h3 {
  margin-top: 0;
  color: #333;
}
```
Это превратится на клиенте примерно в такой CSS:
```css
[data-component-id="c-xyz123"] {
  background-color: white;
  border-radius: 12px;
  padding: 20px;
}

[data-component-id="c-xyz123"] h3 {
  margin-top: 0;
  color: #333;
}
```

### 6. Как работает магия на клиенте: Знакомство с `engine-client.js`

Ты уже видел, как мы декларативно описываем всё поведение на сервере в `manifest.js`. Но как обычная HTML-кнопка с атрибутом `atom-action` заставляет сервер что-то сделать без перезагрузки страницы? И как работают ссылки `atom-link="spa"`?

За всю эту "магию" в браузере отвечает один маленький, но очень умный помощник — скрипт **`engine-client.js`**. Он автоматически подключается на каждую страницу, которую рендерит Serverokey. Давай разберёмся, как он работает.

#### Принцип №1: Единый "Слушатель"

Чтобы не вешать на каждую кнопку и ссылку отдельный обработчик событий (что было бы очень медленно), `engine-client.js` использует умный подход. Он вешает **один-единственный "слушатель"** на самый верхний уровень страницы (на тег `<body>`).

Представь себе консьержа в большом доме. Вместо того чтобы ставить звонок на каждую квартиру, все посетители подходят к нему. Он смотрит на их приглашение и сам направляет их куда нужно. Наш `engine-client.js` — это такой "консьерж" для всех событий на странице (кликов, ввода текста и т.д.).

#### Как работает `atom-action` (Рабочая лошадка)

Когда ты нажимаешь на кнопку с `atom-action`, происходит следующая цепочка событий:

1.  **Событие:** Пользователь нажимает на кнопку.
2.  **Перехват:** Наш "консьерж" (`engine-client.js`) тут же замечает этот клик.
3.  **Сбор данных:** Он смотрит на кнопку и видит атрибут `atom-action="POST /action/addItem"`. Он понимает, куда нужно отправить запрос. Он также смотрит на атрибуты `name` и `value` у кнопки и, если она находится внутри формы `<form>`, собирает все данные из полей этой формы.
4.  **Запрос на сервер:** Движок формирует и отправляет `fetch`-запрос на сервер по указанному URL (`/action/addItem`), прикрепив к нему все собранные данные в формате JSON.
5.  **Получение ответа:** Сервер, как ты знаешь, выполняет нужный `action`-роут из `manifest.js`, изменяет данные и в ответ присылает JSON с новым HTML-кодом для компонента, который нужно обновить (например, для компонента `receipt`).
6.  **Обновление страницы:** Клиентский движок получает этот HTML и находит на странице контейнер по селектору из `atom-target` (например, `#receipt-container`). Затем он **аккуратно заменяет** его содержимое на новый HTML.
7.  **Сохранение фокуса:** Если ты в этот момент печатал текст в поле поиска, `engine-client.js` позаботится о том, чтобы после обновления фокус остался в этом же поле. Всё происходит быстро и "бесшовно".

#### Как работает `atom-link="spa"` (Быстрый навигатор)

Обычная ссылка перезагружает всю страницу целиком. Это медленно. Ссылка с атрибутом `atom-link="spa"` работает гораздо умнее.

1.  **Перехват клика:** Так же, как и в прошлом примере, "консьерж" перехватывает клик по ссылке и отменяет стандартный переход.
2.  **"Особый" запрос:** Он отправляет `fetch`-запрос на новый URL, но добавляет к нему специальный заголовок, который говорит серверу: "Привет, я SPA-навигация! Не присылай мне всю страницу целиком, мне нужна только основная часть".
3.  **Получение ответа:** Сервер видит этот заголовок и вместо полного HTML рендерит только нужные компоненты для новой страницы и присылает их вместе с новым заголовком страницы (`<title>`) и новыми стилями.
4.  **"Бесшовная" замена:** `engine-client.js` находит на странице главный контейнер для контента (например, `<main id="pageContent-container">`), заменяет в нём HTML на новый, обновляет заголовок страницы в браузере и добавляет/заменяет стили в `<head>`.
5.  **Обновление URL:** В самом конце он меняет адрес в строке браузера с помощью `history.pushState`, но **без перезагрузки страницы**.

#### Итог

Вся сложная работа по отправке запросов, обработке ответов и аккуратному обновлению страницы выполняется одним умным скриптом. А тебе, как архитектору, остаётся только расставлять правильные `atom-*` атрибуты в твоём HTML, чтобы указать ему, что делать.

В этом и заключается мощь Serverokey: ты описываешь **ЧТО** должно произойти, а движок (и на сервере, и на клиенте) берёт на себя заботу о том, **КАК** это сделать.