### Файл: `tests/README.md`

Этот файл нужно создать в папке `serverokey/tests/`. Он будет служить инструкцией для вас и других разработчиков по работе с тестовой системой.

```markdown
# Тестирование Проекта Serverokey

Эта директория содержит все необходимое для автоматического тестирования ядра `serverokey`. Тесты написаны таким образом, чтобы быть максимально изолированными и надежными.

## philosophy

Наша система тестирования построена на двух ключевых принципах:
1.  **Максимальная изоляция:** Каждый отдельный тестовый сценарий (`it`-блок) запускается в собственном, чистом дочернем процессе. Это гарантирует отсутствие побочных эффектов между тестами, проблем с кэшированием `require` и конфликтов файловой системы.
2.  **Декларативное описание:** Тестовые файлы (например, `renderer.test.js`) не запускают тесты напрямую. Они экспортируют объект, описывающий "что" и "как" тестировать. Основную работу по запуску берет на себя скрипт-оркестратор.

## Как пользоваться

### Запуск всех тестов

Для запуска полного набора тестов выполните следующую команду из **корневой директории** проекта (`serverokey/`):

```bash
npm test
```
Скрипт `run-all-tests.js` автоматически найдет все файлы, заканчивающиеся на `.test.js`, и выполнит все сценарии, описанные в них.

### Создание нового файла с тестами

1.  Создайте новый файл в директории `tests/` с суффиксом `.test.js` (например, `action-engine.test.js`).
2.  Импортируйте необходимые утилиты и классы ядра.
3.  Опишите один или несколько тестовых сценариев в виде асинхронных функций.
4.  Экспортируйте их в `module.exports`, следуя структуре, принятой в `renderer.test.js` и `validator.test.js`.

**Пример структуры файла `new-feature.test.js`:**
```javascript
const path = require('path');
// ... другие импорты

// Очистка кэша для тестируемого модуля
const MODULE_PATH = path.resolve(__dirname, '..', 'packages/serverokey/core/my-module.js');
if (require.cache[MODULE_PATH]) {
    delete require.cache[MODULE_PATH];
}

// Вспомогательные функции (можно скопировать из других тестов)
function log(...) { /* ... */ }
function check(...) { /* ... */ }

// Функция-сценарий
async function runMyScenarioTest(appPath) {
    // 1. Инициализация (загрузка модулей)
    // 2. Действие (вызов тестируемой функции)
    // 3. Проверка (использование check())
}

// Экспорт
module.exports = {
    'MyModule: Should do something correctly': {
        options: {
            manifest: { /* ... */ },
            files: { /* ... */ }
        },
        run: runMyScenarioTest
    }
};
```

## План дальнейшего тестирования (Roadmap)

Мы покрыли `Renderer` и `Validator`. Теперь нужно покрыть остальные критически важные части ядра.

### 1. `ActionEngine` (Приоритет: ВЫСОКИЙ)

Это самый важный следующий шаг. `ActionEngine` — это сердце всей бизнес-логики.

**Что нужно проверить:**
*   **Шаг `set`:** Корректно ли устанавливаются значения в `context` и `data`. Проверить простые присваивания, вычисления, работу с массивами (`.push`, `.map`, `.filter`).
*   **Шаг `if/then/else`:** Правильно ли работает условная логика. Проверить простые условия, сложные (`&&`, `||`) и условия, зависящие от данных (`data.user.isAdmin`).
*   **Шаг `run`:** Корректно ли вызывается и выполняется код из внешнего JS-файла. Проверить, что он может изменять контекст.
*   **Шаг `action:run`:** Правильно ли один экшен вызывает другой (внутренний) и как передается/возвращается контекст `data`.
*   **Шаг `http:get`:** Имитировать успешный и неуспешный HTTP-запрос (потребуется мок-сервер, например, с помощью `http.createServer`) и проверить, что результат правильно сохраняется в `context`.
*   **Обработка ошибок:** Что происходит, если JS-выражение в `to` или `if` синтаксически неверно.

### 2. Коннекторы (`ConnectorManager` и др.) (Приоритет: СРЕДНИЙ)

**Что нужно проверить:**
*   **`in-memory`:** Простота чтения и записи. Убедиться, что данные не сохраняются между перезапусками (это неявная проверка в нашей системе, т.к. каждый тест — новый "запуск").
*   **`wise-json`:** Это самый важный коннектор.
    *   Корректность записи/чтения `items` и мета-данных.
    *   Работа `initialState`, когда база данных пуста.
    *   Работа миграций (`migrations`): создать данные старой структуры, затем запустить чтение с новой конфигурацией миграции и проверить, что данные были обновлены.
    *   Работа вычисляемых полей (`computed`).

### 3. `AuthEngine` (Приоритет: СРЕДНИЙ)

**Что нужно проверить:**
*   Создание сессии (`createSession`) и ее получение (`getSession`).
*   Логика `auth:login` и `auth:logout` в `steps`. Для этого понадобятся тесты, имитирующие `RequestHandler`.
*   Защита роутов: попытка доступа к защищенному роуту без сессии.

### 4. `SocketEngine` (Приоритет: НИЗКИЙ)

Это самый сложный для тестирования компонент. Потребуется создание фейковых WebSocket-клиентов.
*   Подписка клиента на канал.
*   Отправка уведомления при записи в `watch`-коннектор.
*   Проверка, что инициатор изменения **не получает** уведомление обратно.
