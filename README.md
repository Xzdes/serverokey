# Serverokey 🚀

**Serverokey** (Сервер-окей) — это атомарный, zero-dependency движок для бэкенда на Node.js (CommonJS), созданный для безопасного и эффективного взаимодействия с LLM (Large Language Models). Его главная задача — позволить LLM создавать веб-приложения, описывая их структуру и логику декларативно, минимизируя риск ошибок.

*   **Автор:** Xzdes
*   **Контакт:** [xzdes@yandex.ru](mailto:xzdes@yandex.ru)
*   **Репозиторий:** [https://github.com/Xzdes/serverokey](https://github.com/Xzdes/serverokey)

![Пример работы приложения "Касса"](https://github.com/Xzdes/serverokey/raw/main/docs/kassa-app-demo.png)  
*(Предполагается, что вы добавите скриншот вроде этого в папку `docs`)*

---

## 🎯 Философия: Защита от ошибок LLM

Современные LLM отлично справляются с написанием изолированной логики, но часто допускают ошибки в вещах, требующих контекста и точности: пути к файлам, DOM-манипуляции, управление состоянием.

**Serverokey** решает эту проблему, забирая у LLM все "опасные" обязанности.

1.  **Запрет на написание путей:** Движок находит все файлы сам, следуя строгим конвенциям. LLM оперирует только именами (`'addItem'`, `'receipt'`).
2.  **Запрет на рендеринг:** LLM не пишет, как обновлять DOM. Она лишь указывает в манифесте, какой компонент нужно перерисовать после действия (`update: 'receipt'`).
3.  **Запрет на управление состоянием:** LLM не читает и не сохраняет файлы. Она описывает структуру данных и получает их в изолированном контексте. Движок сам заботится о загрузке и сохранении.
4.  **Единственная точка входа:** LLM взаимодействует только с одним файлом — `manifest.js`. Это её "пульт управления" всем приложением.

> **Идея проста:** LLM из "программиста на все руки" превращается в "системного архитектора", который декларирует, **ЧТО** нужно сделать, а движок реализует, **КАК** это сделать.

---

## 🎨 Архитектура в деталях

Весь рабочий процесс построен вокруг центрального манифеста и строгой структуры папок.

### 1. Структура проекта

Движок диктует нерушимую структуру. LLM работает только внутри папки `app`.

```
/my-project
  ├── kassa-app/                <-- Папка вашего приложения
  │   ├── manifest.js           <-- ⭐️ ЕДИНСТВЕННЫЙ файл, который редактирует LLM
  │   └── app/
  │       ├── actions/          <-- Атомарные функции для изменения данных
  │       │   └── addItem.js
  │       ├── components/       <-- HTML-шаблоны
  │       │   └── receipt.html
  │       └── data/             <-- JSON-файлы с данными
  │           └── receipt.json
  │
  ├── engine.js                 <-- Сам движок (не трогаем)
  └── engine-client.js          <-- Клиентский скрипт (не трогаем)
```

### 2. Поток данных и рендеринга

Движок работает по принципу "HTML-over-the-wire", вдохновленному HTMX.

#### Полная загрузка страницы (`GET /`)

```ascii
                                            ┌──────────────────┐
                                            │  manifest.js     │
                                            │ (type: 'view')   │
                                            └─────────┬────────┘
                                                      │ 1. Читает конфигурацию
 ╔═════════╗       ╔═════════════════╗      ┌─────────▼────────┐      ╔════════════════╗
 ║ Browser ║──────>║   HTTP Server   ║─────>║   AtomEngine     ║─────>║   Файловая     ║
 ╚═════════╝ 2. GET║  (engine.js)    ║      │ (core/renderer.js) │<────║   система      ║
             /     ╚═════════════════╝      └─────────┬────────┘ 3.   ╚════════════════╝
                                                      │ 4. Рендерит   (загружает шаблоны,
                                            ┌─────────▼────────┐    JSON-данные)
                                            │ Готовый HTML + JS│
                                            └─────────┬────────┘
                                                      │ 5. Отправляет ответ
 ╔═════════╗       ╔═════════════════╗      ┌─────────┴────────┐
 ║ Browser ║<──────║   HTTP Server   ║<─────┤   HTML Response  │
 ╚═════════╝ 6.    ╚═════════════════╝      └──────────────────┘
   Рендерит
   страницу
```

#### Обработка действия (`POST /action/...`)

```ascii
                                                       ┌────────────────────┐
                                                       │  manifest.js       │
                                                       │ (type: 'action')   │
                                                       └──────────┬─────────┘
                                                                  │ 1. Читает конфигурацию
 ╔═════════╗       ╔════════════════╗       ┌──────────▼─────────┐      ╔════════════╗
 ║ Browser ║──────>║  engine-client ║──────>║      AtomEngine    ║─────>║ app/actions/ ║
 ╚═════════╝ Клик  ╚════════════════╝  POST ║  (core/request-..  ║ 2.   ╚════════════╝
                                       /..  └──────────┬─────────┘    Вызывает action
                                                      │ 3.
                                            ┌─────────▼─────────┐
                                            │ Изолированный     │
                                            │ Контекст { data } │
                                            └─────────┬─────────┘
                                                      │ 4. Action мутирует контекст
                                            ┌─────────▼─────────┐
                                            │    AtomEngine     │
                                            └─────────┬─────────┘
                                                      │ 5. Сохраняет данные (core/data-manager.js)
                                            ┌─────────▼─────────┐      ╔════════════╗
                                            │  Рендеринг        │<────>║ app/comp...║
                                            │ (core/renderer.js)│      ╚════════════╝
                                            └─────────┬─────────┘ 6. Рендерит только
                                                      │              нужный компонент
 ╔═════════╗       ╔════════════════╗       ┌─────────▼─────────┐
 ║ Browser ║<──────║  engine-client ║<──────┤  HTML Фрагмент    │
 ╚═════════╝       ╚════════════════╝       └───────────────────┘
   Обновляет 8. innerHTML
   часть
   страницы
```

---

## 🛠️ Как это использовать

### 1. Установка

Клонируйте репозиторий. **Serverokey** не требует зависимостей, поэтому `npm install` не нужен.

```bash
git clone https://github.com/Xzdes/serverokey.git
cd serverokey
```

### 2. Запуск

Запустите движок командой:
```bash
node engine.js
```
Сервер запустится на `http://localhost:3000`.

### 3. Рабочий процесс для LLM

Представьте, что вам дана задача: **"Добавь возможность удалять товары из чека по одному"**.

LLM выполнит следующие шаги:

**Шаг 1: Редактирование `manifest.js`**

LLM добавляет новый маршрут типа `action` в секцию `routes`:
```javascript
// ...
'POST /action/removeItem': {
  type: 'action',
  handler: 'removeItem',      // Имя файла в app/actions/
  reads: ['receipt'],         // Что нужно прочитать для работы
  writes: ['receipt'],        // Что будет изменено
  update: 'receipt'           // Какой компонент обновить на клиенте
}
// ...
```

**Шаг 2: Создание файла `app/actions/removeItem.js`**

LLM пишет простую, изолированную функцию. Движок передаст ей `context` и `body` запроса.
```javascript
// app/actions/removeItem.js
module.exports = (context, body) => {
  // body будет содержать, например, { index: 2 }
  const indexToRemove = parseInt(body.index, 10);
  
  if (!isNaN(indexToRemove) && context.receipt.items[indexToRemove]) {
    context.receipt.items.splice(indexToRemove, 1);
    
    // Пересчет суммы
    const newTotal = context.receipt.items.reduce((sum, item) => sum + parseFloat(item.price), 0);
    context.receipt.total = newTotal.toFixed(2);
  }
};
```

**Шаг 3: Модификация `app/components/receipt.html`**

LLM добавляет кнопку удаления для каждого элемента в цикле.
```html
<!-- app/components/receipt.html -->
...
<ul>
  {{#each receipt.items}}
    <li>
      {{this.name}} - {{this.price}} руб.
      <!-- Новая кнопка -->
      <button 
        atom-action="POST /action/removeItem"
        atom-target="#receipt-container"
        name="index"
        value="{{@index}}"  <!-- Handlebars предоставляет @index в циклах -->
      >
        X
      </button>
    </li>
  {{/each}}
</ul>
...
```
*(Примечание: для передачи `@index` нужно будет немного доработать `engine-client.js`, чтобы он мог собирать `value` из кнопок без формы, или обернуть это в `<form>`)*

**Результат:** Задача решена без единого шанса на критическую ошибку. LLM не придумывала пути, не трогала DOM, не управляла файлами — она просто следовала строгим, но понятным правилам.

---

## 💡 Ключевые концепции API

### `manifest.js`

#### `data`
Описывает источники данных. Движок сам найдет `app/data/{key}.json`.
```javascript
data: {
  // ключ 'receipt' -> файл 'app/data/receipt.json'
  receipt: {
    // Если файл не найден, будет создано это начальное состояние
    initialState: { items: [], total: '0.00' }
  },
  positions: {}
}
```

#### `components`
Описывает компоненты и их стили.
```javascript
components: {
  // Простой компонент-шаблон
  mainLayout: 'main-layout.html',
  
  // Компонент со стилями
  receipt: {
    template: 'receipt.html',
    styles: {
      // '#' - стили для корневого элемента компонента
      '#': { 'background-color': '#f9f9f9' },
      // Стили для элемента с id="clear-btn" внутри компонента
      '#clear-btn': {
        'background-color': '#ffdddd',
        'hover:background-color': '#ffbaba' // Поддержка псевдо-классов
      }
    }
  }
}
```

#### `routes`
Связывает URL с действиями.
*   `type: 'view'`: Рендеринг полной страницы.
    *   `layout`: Имя основного шаблона.
    *   `inject`: Объект, где ключ — имя плейсхолдера `<atom-inject into="...">`, а значение — имя компонента для вставки.
*   `type: 'action'`: Выполнение серверной логики.
    *   `handler`: Имя `action`-функции.
    *   `reads`: Массив ключей из `data`, которые будут переданы в `context` для чтения.
    *   `writes`: Массив ключей из `data`, которые `action` имеет право изменить.
    *   `update`: Имя компонента, который будет перерисован и отправлен клиенту.

---

## 🔮 Будущие улучшения

*   [ ] Валидация данных по JSON-схемам.
*   [ ] Поддержка WebSocket для real-time обновлений (`broadcast: 'componentName'`).
*   [ ] Улучшенный синтаксис для стилей (например, поддержка вложенности).
*   [ ] Горячая перезагрузка (Hot-reloading) для `manifest.js` и компонентов.

---

Этот проект — эксперимент в области взаимодействия человека и машины, направленный на создание надежных и предсказуемых программных систем. Буду рад вашим идеям и вкладу!

**Xzdes**