# 5. Создание Интерфейса: Компоненты и Шаблоны

Пользовательский интерфейс в Serverokey строится на основе концепции **компонентов**. Это независимые, переиспользуемые блоки, состоящие из HTML-шаблона и, опционально, изолированных CSS-стилей. Такой подход позволяет создавать сложные интерфейсы из простых "строительных кирпичиков".

## 1. Регистрация Компонентов

Прежде чем использовать компонент, его необходимо "объявить" в секции `components` файла `manifest.js`. Движок должен знать о существовании каждого компонента.

Все пути к файлам компонентов указываются относительно директории `app/components/`.

**Примеры регистрации:**

```javascript
// manifest.js
components: {
  // 1. Простой компонент: только HTML-шаблон.
  // 'mainLayout' - это имя, которое мы будем использовать в роутах.
  // 'main-layout.html' - это имя файла в `app/components/`.
  mainLayout: 'main-layout.html',

  // 2. Компонент с шаблоном и стилями.
  receipt: {
    template: 'receipt.html', // Путь к файлу шаблона
    style: 'receipt.css'      // Путь к файлу стилей
  },
  
  // 3. Компонент-обертка для страницы аутентификации
  authLayout: 'auth-layout.html'
}
```

## 2. Шаблонизатор Mustache.js

Для рендеринга HTML и вставки динамических данных Serverokey использует **Mustache.js**. Это простой, но мощный "logic-less" (безлогический) шаблонизатор. Его главная особенность — он не позволяет выполнять сложный код внутри HTML, что делает шаблоны безопасными и легко читаемыми.

### Вывод Переменных
Для вставки значения переменной из контекста данных используются двойные фигурные скобки `{{ ... }}`. Движок по умолчанию экранирует все HTML-теги внутри переменной для предотвращения XSS-атак.

**Доступ к данным:** Напоминаем, что все данные из коннекторов доступны через объект `data`, глобальные переменные — через `globals`, а информация о пользователе — через `user`.

```html
<!-- Отображение имени приложения из globals -->
<h1>{{globals.appName}}</h1>

<!-- Отображение имени пользователя -->
<p>Кассир: {{user.name}}</p>

<!-- Отображение поля из коннектора -->
<p>Итого к оплате: {{data.receipt.finalTotal}} руб.</p>
```

### Условное Отображение (Секции)
Mustache не имеет `if-else` в привычном понимании. Вместо этого он использует **секции**.

*   **`{{#имя_переменной}}...{{/имя_переменной}}`**: Содержимое этого блока будет отображено только в том случае, если `имя_переменной` имеет "истинное" значение (т.е. не является `false`, `null`, `undefined`, `0`, пустой строкой или пустым массивом `[]`).

*   **`{{^имя_переменной}}...{{/имя_переменной}}`**: Инвертированная секция. Содержимое будет отображено, если `имя_переменной` имеет "ложное" значение.

**Пример:**
```html
{{#data.receipt.items}}
  <!-- Этот ul будет показан, только если массив items не пустой -->
  <ul>
    ...
  </ul>
{{/data.receipt.items}}

{{^data.receipt.items}}
  <!-- Этот div будет показан, только если массив items пустой -->
  <div class="empty-state">Чек пуст</div>
{{/data.receipt.items}}
```

### Циклы по Массивам
Циклы — это естественное применение секций. Если переменная, на которую указывает секция, является массивом, то блок будет повторен для **каждого элемента** этого массива. Внутри блока можно обращаться к свойствам текущего элемента напрямую.

**Пример:**
```html
<ul>
  <!-- Для каждого элемента в массиве data.positions.items... -->
  {{#data.positions.items}}
    <!-- ...будет создан этот li. `name` и `price` - это свойства элемента. -->
    <li>{{name}} ({{price}} руб.)</li>
  {{/data.positions.items}}
</ul>
```

## 3. "Атомарные" Атрибуты Serverokey

Движок расширяет стандартный HTML набором специальных `atom-*` атрибутов, которые оживляют интерфейс.

*   **`atom-action="METHOD /url"`**
    Главный атрибут для взаимодействия. Он указывает, какой `action`-роут на сервере нужно вызвать.
    *   Пример: `atom-action="POST /action/addItem"`

*   **`atom-target="#css-selector"`**
    Указывает, какой элемент на странице нужно обновить, когда `action` вернет новый HTML. Значением должен быть уникальный CSS-селектор (обычно `id`).
    *   Пример: `atom-target="#receipt-container"`

*   **`atom-event="событие"`** (Опционально)
    Указывает, по какому DOM-событию должен сработать `atom-action`.
    *   **По умолчанию:** `click` для большинства элементов (кнопки, ссылки) и `submit` для тега `<form>`.
    *   **Часто используемое значение:** `input` для полей ввода, чтобы экшен срабатывал при каждом вводе символа (например, для "живого" поиска).
    *   Пример: `atom-event="input"`

*   **`atom-link="spa"`**
    Превращает обычную ссылку `<a>` в ссылку для одностраничного приложения (SPA). Вместо полной перезагрузки страницы, клиентский движок перехватит клик, запросит у сервера только нужный контент и обновит основную часть страницы.
    *   Пример: `<a href="/register" atom-link="spa">Перейти к регистрации</a>`

**Полный пример интерактивного элемента:**
```html
<input 
  type="text" 
  name="query"
  atom-action="POST /action/filterPositions" 
  atom-target="#positionsList-container"
  atom-event="input"
>
```

## 4. Директива `atom-if` для Серверного Рендеринга

Это мощная директива, которая выполняется **на сервере** до отправки HTML клиенту. Если JavaScript-выражение в атрибуте возвращает `false`, то сам элемент и все его дочерние элементы будут **полностью вырезаны** из HTML.

Это полезно для контроля доступа или отображения блоков в зависимости от состояния данных.

```html
<!-- Этот блок увидят только админы -->
<div atom-if="user.role === 'admin'">
  <a href="/admin-panel">Панель администратора</a>
</div>

<!-- Показать сообщение об ошибке, если она есть в URL -->
<p class="error" atom-if="url.query.error">Неверный логин или пароль.</p>
```

## 5. Изолированные Стили (Scoped CSS)

Когда вы подключаете файл стилей к компоненту в `manifest.js`, Serverokey автоматически делает эти стили **изолированными**. Каждый компонент при рендеринге получает уникальный атрибут `data-component-id="c-xxxxxx"`, и все CSS-правила из его файла стилей модифицируются так, чтобы применяться только внутри этого атрибута.

Это решает глобальную проблему CSS — конфликт имен классов. Стили одного компонента никогда не "сломают" стили другого.

Для стилизации самого корневого элемента компонента (того, на котором будет `data-component-id`), используйте специальный псевдоселектор `:host`.

**Пример (`receipt.css`):**
```css
/* Стили для корневого div компонента receipt */
:host {
  background-color: white;
  border-radius: 12px;
  padding: 20px;
}

/* Этот стиль применится только к h3 внутри компонента receipt */
h3 {
  margin-top: 0;
  color: #333;
}
```
Это превратится на клиенте примерно в такой CSS:
```css
[data-component-id="c-xyz123"] {
  background-color: white;
  border-radius: 12px;
  padding: 20px;
}

[data-component-id="c-xyz123"] h3 {
  margin-top: 0;
  color: #333;
}
```