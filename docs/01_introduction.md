# 1. Введение в Serverokey: Философия и Архитектура

Добро пожаловать в Serverokey — декларативный движок для Node.js, созданный с одной главной целью: изменить подход к разработке веб-приложений, особенно при работе с Большими Языковыми Моделями (LLM).

## Проблема: LLM как "Младший Программист"

Современные LLM, такие как GPT-4, обладают феноменальными способностями к генерации кода. Однако при создании полноценных приложений они часто сталкиваются с проблемами:

1.  **Потеря контекста:** Сложные проекты требуют удержания в "памяти" множества файлов, зависимостей и соглашений, что приводит к ошибкам.
2.  **Императивные ошибки:** LLM может сгенерировать синтаксически верный, но логически неверный императивный код (например, перепутать порядок аргументов, забыть про `await`).
3.  **Небезопасность:** Прямая генерация кода, работающего с файловой системой (`fs`) или базой данных, несет в себе риски безопасности.
4.  **"Шум" обвязки:** Вместо концентрации на бизнес-логике, LLM тратит ресурсы на написание шаблонного кода: настройка сервера, обработка HTTP-запросов, парсинг тела запроса и т.д.

В результате LLM выступает в роли "младшего программиста", который постоянно нуждается в проверке, отладке и исправлении со стороны человека.

## Решение: LLM как "Архитектор"

**Serverokey предлагает радикально иной подход.**

Мы забираем у LLM обязанность писать *императивный код* и даем ему инструмент для *декларативного описания архитектуры*. Вместо того чтобы говорить "КАК" сделать, LLM описывает "**ЧТО**" должно быть сделано в едином центральном файле — `manifest.js`.

**Ключевая аналогия:** LLM перестает быть каменщиком, который укладывает кирпичи, и становится архитектором, который работает с чертежом всего здания.

### Основные Принципы Архитектуры Serverokey

#### 1. Единый Источник Правды (`manifest.js`)
Всё приложение — его данные, компоненты интерфейса, маршруты, бизнес-логика и настройки безопасности — описывается в одном файле. Это позволяет LLM (и человеку) видеть всю структуру проекта целиком, что кардинально снижает когнитивную нагрузку и вероятность контекстных ошибок.

#### 2. Декларативность превыше всего
Вы описываете *желаемый результат*, а движок берет на себя его реализацию.
*   **Плохо (императивно):** "Напиши код, который подключается к базе данных, выполняет SQL-запрос `SELECT *`, обрабатывает результат и отдает его клиенту".
*   **Хорошо (декларативно с Serverokey):** "Объяви `коннектор` к базе данных и `роут`, который `читает` данные из этого коннектора и `отображает` их в `компоненте`".

#### 3. Изоляция и Безопасность ("Песочница")
Движок выступает в роли посредника и операционной системы для вашего приложения. LLM работает в безопасной "песочнице":
*   **Нет прямого доступа к `fs` или `require`:** Вся работа с файлами (загрузка компонентов, данных) и модулями (`bcrypt`) происходит через декларативные конструкции, которые контролирует движок.
*   **Безопасный рендеринг:** Используется Mustache.js, который по умолчанию экранирует все выводимые данные, предотвращая XSS-атаки.
*   **Предсказуемые `steps`:** Логика, описанная в `steps`, выполняется в изолированном контексте, что предотвращает побочные эффекты.

#### 4. "Эмпатичное Ядро" и Цикл с Обратной Связью
Движок спроектирован так, чтобы помогать, а не наказывать за ошибки.
*   **Умный валидатор:** Перед запуском специальный скрипт (`npm run validate`) проверяет `manifest.js` на десятки логических ошибок и опечаток, предлагая конкретные исправления (`Did you mean...?`).
*   **Прощающий ошибки `runtime`:** В режиме отладки движок старается не "падать" от мелких ошибок в логике (например, обращение к несуществующему полю), а выводить предупреждение в консоль.
*   **Комфорт для LLM:** Такая среда позволяет LLM безопасно экспериментировать и предлагать изменения, получая четкую и полезную обратную связь для самокоррекции.

## Итог
Serverokey — это не просто очередной фреймворк. Это **парадигмальный сдвиг** в сторону декларативной разработки, созданный специально для эпохи искусственного интеллекта. Он позволяет использовать сильные стороны LLM (архитектурное мышление, понимание структур данных) и нивелировать их слабые стороны (ошибки в деталях реализации, потеря контекста).

**В следующих разделах мы подробно рассмотрим, как эта философия воплощается в каждой части движка.**