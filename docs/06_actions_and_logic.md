# 6. Серверная Логика: Роуты типа `action` и Магия `steps`

Если `view`-роуты отвечают за первоначальную отрисовку страниц, то `action`-роуты — это рабочие лошадки вашего приложения. Они обрабатывают все взаимодействия с пользователем, выполняют бизнес-логику, изменяют данные и решают, как обновить интерфейс. В Serverokey вся эта мощь заключена в декларативной секции `steps`.

## Анатомия `action`-роута

Каждый `action`-роут в `manifest.js` описывает полный цикл "запрос-обработка-ответ".

```javascript
// manifest.js
'POST /action/addItem': {
  // 1. Тип роута
  type: 'action',

  // 2. Какие данные нужно загрузить в контекст перед выполнением
  reads: ['positions', 'receipt', 'user'],

  // 3. Какие коннекторы нужно будет сохранить в БД после выполнения
  writes: ['receipt'],

  // 4. Какой компонент на клиенте нужно обновить новым HTML
  update: 'receipt',
  
  // 5. Главная часть: массив шагов с бизнес-логикой
  steps: [
    // ... здесь происходит вся магия ...
  ]
}
```

*   `type: 'action'`: Обязательно. Указывает движку, что это роут для выполнения логики.
*   `reads`: Массив имен коннекторов. Перед выполнением `steps`, движок автоматически загрузит актуальные данные из этих коннекторов и поместит их в контекст.
*   `writes`: Массив имен коннекторов. После выполнения всех `steps`, движок автоматически сохранит измененные данные из контекста в эти коннекторы.
*   `update`: Имя компонента, который нужно перерисовать на стороне клиента после успешного выполнения экшена. Движок вернет клиенту новый HTML именно для этого компонента. *(Это свойство не нужно, если экшен заканчивается редиректом)*.

## Контекст `steps`: Ваше Рабочее Пространство

Прежде чем разбирать сами шаги, нужно понять, с какими данными они работают. Для каждого `action`-роута движок создает временный **контекст** — это JavaScript-объект, который "живет" только во время выполнения этого экшена.

Внутри `steps` вы имеете доступ к следующим свойствам контекста:

*   **`data`**: Объект, содержащий состояния всех коннекторов, которые вы перечислили в `reads`.
    *   Пример: `data.receipt`, `data.positions.items`.
*   **`user`**: Объект текущего авторизованного пользователя. Если пользователь не вошел в систему, `user` будет `null`.
    *   Пример: `user.name`, `user.role`.
*   **`body`**: Объект с данными, которые пришли с клиента. Обычно это поля формы.
    *   Пример: `body.login`, `body.coupon_code`.
*   **`context`**: Ваша личная "песочница" или временное хранилище. Вы можете создавать и изменять любые переменные в `context`, чтобы хранить промежуточные результаты вычислений. Эти переменные не сохраняются после выполнения экшена.
    *   Пример: `context.productToAdd`, `context.isValid`.

## Каталог Шагов (`steps`)

`steps` — это массив объектов, где каждый объект представляет одну операцию. Они выполняются последовательно, сверху вниз.

### `set`
Самый частый шаг. Он вычисляет JavaScript-выражение из поля `to` и присваивает результат переменной, указанной в `set`.

```javascript
// Установить статичное значение (обратите внимание на вложенные кавычки)
{ "set": "data.receipt.statusMessage", "to": "'Купон успешно применен!'" }

// Присвоить значение из body
{ "set": "context.searchQuery", "to": "body.query" }

// Выполнить сложное вычисление и сохранить результат
{ "set": "data.receipt.total", "to": "data.receipt.items.reduce((sum, item) => sum + item.price, 0)" }
```

### `if`, `then`, `else`
Позволяет выполнять условную логику. Выражение в `if` вычисляется. Если оно истинно, выполняются шаги из массива `then`. Иначе — выполняются шаги из `else`.

```javascript
{
  "if": "data.receipt.total > 500 && user.role === 'premium'",
  "then": [
    { "set": "data.receipt.discountPercent", "to": 20 }
  ],
  "else": [
    { "set": "data.receipt.discountPercent", "to": 10 }
  ]
}
```

### `run`
Выполняет код из внешнего JS-файла, расположенного в `app/actions/`. Это полезно для вынесения очень сложной, императивной логики. Имя файла указывается без расширения. Движок автоматически нормализует путь.

```javascript
// Вызовет файл app/actions/filterPositions.js
{ "run": "filterPositions" }
```
Файл должен экспортировать функцию вида `module.exports = (context, body) => { ... }`. Эта функция может напрямую изменять переданный `context`.

### `action:run`
**Один из самых мощных шагов.** Выполняет другой `action`-роут из вашего же `manifest.js` по его имени. Это позволяет создавать переиспользуемые "подпрограммы".

1.  **Сначала определите внутренний (internal) роут:**
    ```javascript
    "recalculateReceiptLogic": {
      "type": "action",
      "internal": true, // Флаг для валидатора, что ему не нужен update/redirect
      "steps": [ /* ... логика пересчета ... */ ]
    }
    ```
2.  **Затем вызовите его из другого экшена:**
    ```javascript
    "POST /action/addItem": {
      "type": "action",
      "steps": [
        /* ... логика добавления товара ... */
        { "action:run": { "name": "recalculateReceiptLogic" } }
      ]
      /* ... */
    }
    ```
Весь текущий `data`-контекст автоматически передается во внутренний экшен и возвращается обратно после его выполнения.

### Служебные и Сетевые Шаги

*   `{ "auth:login": "..." }`: Создает сессию для пользователя. Ожидает объект пользователя.
*   `{ "auth:logout": true }`: Уничтожает текущую сессию.
*   `{ "client:redirect": "'/url'" }`: Отправляет клиенту команду на перенаправление.
*   `{ "http:get": { "url": "...", "saveTo": "..." } }`: Выполняет GET-запрос к внешнему API и сохраняет JSON-ответ в `context`.

С помощью этого набора `steps` вы можете декларативно описать практически любую бизнес-логику, сохраняя `manifest.js` чистым и читаемым.