### Файл: `tests/README.md` (Актуальная версия)

```markdown
# Тестирование Проекта Serverokey

Эта директория содержит все необходимое для автоматического тестирования ядра `serverokey`. Тесты написаны таким образом, чтобы быть максимально изолированными и надежными, что позволяет нам находить и исправлять баги в ядре до того, как они повлияют на реальные приложения.

## Философия

Наша система тестирования построена на двух ключевых принципах:

1.  **Максимальная изоляция:** Каждый отдельный тестовый сценарий (например, "проверка шага 'set'") запускается в собственном, чистом дочернем процессе. Это гарантирует отсутствие побочных эффектов между тестами, проблем с кэшированием `require` и конфликтов файловой системы.
2.  **Декларативное описание:** Тестовые файлы (например, `renderer.test.js`) не запускают тесты напрямую. Они экспортируют объект, описывающий "что" и "как" тестировать. Основную работу по запуску берет на себя скрипт-оркестратор `run-all-tests.js`.

## Как пользоваться

### Запуск всех тестов

Для запуска полного набора тестов выполните следующую команду из **корневой директории** проекта (`serverokey/`):

```bash
npm test
```
Скрипт `run-all-tests.js` автоматически найдет все файлы в этой директории, заканчивающиеся на `.test.js`, и последовательно выполнит все сценарии, описанные в них.

### Создание нового файла с тестами

1.  Создайте новый файл в директории `tests/` с суффиксом `.test.js` (например, `connectors.test.js`).
2.  Импортируйте необходимые утилиты и классы ядра, используя абсолютные пути от корня проекта. Не забудьте добавить очистку кэша `require` для тестируемого модуля.
3.  Опишите один или несколько тестовых сценариев в виде асинхронных функций, принимающих `appPath` в качестве аргумента.
4.  Экспортируйте их в `module.exports`, следуя структуре, принятой в существующих тестовых файлах.

**Пример структуры файла `new-feature.test.js`:**
```javascript
const path = require('path');
const PROJECT_ROOT = path.resolve(__dirname, '..');

// Очистка кэша для тестируемого модуля
const MODULE_PATH = path.join(PROJECT_ROOT, 'packages/serverokey/core/my-module.js');
if (require.cache[MODULE_PATH]) {
    delete require.cache[MODULE_PATH];
}

// Вспомогательные функции (log, check)
// ...

// Функция-сценарий
async function runMyScenarioTest(appPath) {
    // 1. Инициализация (загрузка модулей, создание экземпляров)
    // 2. Действие (вызов тестируемой функции)
    // 3. Проверка (использование check())
}

// Экспорт
module.exports = {
    'MyModule: Should do something correctly': {
        options: {
            manifest: { /* ... */ },
            files: { /* ... */ }
        },
        run: runMyScenarioTest
    }
};
```

## План дальнейшего тестирования (Roadmap)

На данный момент мы успешно покрыли тестами три ключевых модуля ядра: **`Renderer`**, **`Validator`** и **`ActionEngine`**.

Следующие шаги для достижения 100% покрытия ядра:

### 1. Коннекторы (`ConnectorManager` и др.) (Приоритет: ВЫСОКИЙ)

Это следующий логичный шаг, так как данные — основа любого приложения.

**Что нужно проверить:**
*   **`in-memory`:** Простота чтения и записи. Убедиться, что данные не сохраняются между перезапусками (это неявная проверка в нашей системе, так как каждый тест — новый "запуск").
*   **`wise-json`:** Это самый важный коннектор.
    *   Корректность записи/чтения `items` и мета-данных.
    *   Работа `initialState`, когда база данных пуста.
    *   **Работа миграций (`migrations`):** Создать данные старой структуры, затем запустить чтение с новой конфигурацией миграции и проверить, что данные были автоматически обновлены.
    *   **Работа вычисляемых полей (`computed`):** Проверить правильность вычислений.

### 2. `AuthEngine` и `RequestHandler` (Приоритет: СРЕДНИЙ)

Эти модули тесно связаны, их можно тестировать вместе.

**Что нужно проверить:**
*   Создание сессии (`createSession`) и ее получение (`getSession`).
*   Логика `auth:login` и `auth:logout` в `steps`.
*   Защита роутов: симуляция запроса к защищенному роуту без сессии и проверка редиректа.

### 3. `SocketEngine` (Приоритет: НИЗКИЙ)

Это самый сложный для тестирования компонент, так как он асинхронный и основан на событиях. Потребуется создание фейковых WebSocket-клиентов (например, с помощью библиотеки `ws`).

**Что нужно проверить:**
*   Подписка клиента на канал после установки соединения.
*   Отправка уведомления по каналу при записи в отслеживаемый коннектор.
*   Проверка, что инициатор изменения **не получает** WebSocket-уведомление обратно.