# Serverokey 🚀

**Serverokey** (Сервер-окей) — это атомарный, декларативный движок для бэкенда на Node.js, спроектированный для создания веб-приложений с помощью LLM (Large Language Models). Его главная задача — превратить LLM из "программиста" в "архитектора", который описывает **ЧТО** нужно сделать, а не **КАК**.

*   **Автор:** Xzdes
*   **Контакт:** [xzdes@yandex.ru](mailto:xzdes@yandex.ru)
*   **Репозиторий:** [https://github.com/Xzdes/serverokey](https://github.com/Xzdes/serverokey)

---

## 🎯 Философия: Архитектура вместо Кода

Современные LLM отлично генерируют код, но часто ошибаются в деталях, требующих контекста. Serverokey решает эту проблему, заменяя написание императивного кода на заполнение декларативных структур в центральном файле — `manifest.js`.

1.  **Декларативные Действия:** Вместо JS-кода для добавления товара в корзину, LLM описывает операцию: `{"operation": "push", "target": "receipt.items", ...}`.
2.  **Вычисляемые Данные:** Вместо JS-кода для пересчета суммы заказа, LLM описывает ее как формулу: `{"target": "total", "formula": "sum(items, 'price')"}`.
3.  **Декларативная Видимость:** Вместо логики в шаблонах, LLM управляет отображением через HTML-атрибут: `atom-if="receipt.items.length > 0"`.
4.  **Полная Изоляция:** Движок сам находит файлы, обновляет DOM, управляет состоянием и обеспечивает безопасность. LLM не имеет прямого доступа к файловой системе или рендерингу.

> **Результат:** LLM работает с **единой точкой входа** (`manifest.js`) и генерирует предсказуемые, безопасные и легко проверяемые веб-приложения.

---

## 🎨 Архитектура в деталях

Весь рабочий процесс построен вокруг центрального манифеста (`manifest.js`), который является "мозгом" приложения.

### 1. Структура проекта

Движок диктует строгую и понятную структуру. LLM работает только внутри папки `app`.

```
/my-project
  ├── kassa-app/                <-- Папка вашего приложения
  │   ├── manifest.js           <-- ⭐️ Единственный файл, который определяет ВСЮ логику
  │   └── app/
  │       ├── actions/          <-- (Опционально) Сложная JS-логика
  │       ├── components/       <-- HTML-шаблоны и их CSS-стили
  │       ├── data/             <-- JSON-файлы с данными (состояние)
  │       └── operations/       <-- (Опционально) Кастомные, переиспользуемые операции
  │
  ├── core/                     <-- Ядро движка (не трогаем)
  ├── engine.js                 <-- Точка входа сервера (не трогаем)
  └── engine-client.js          <-- Клиентский скрипт (не трогаем)
```

### 2. Поток данных и рендеринга

Движок работает по принципу "HTML-over-the-wire", но с "умным" обновлением DOM на клиенте для сохранения фокуса и состояния.

#### Полная загрузка страницы (`GET /`)

```ascii
                                            ┌──────────────────┐
                                            │   manifest.js    │
                                            │  (route: 'view') │
                                            └─────────┬────────┘
                                                      │ 1. Анализ маршрута
 ╔═════════╗       ╔════════════════╗       ┌─────────▼────────┐      ╔════════════════╗
 ║ Browser ║──────>║  RequestHandler  ║─────>║     Renderer     ║─────>║   app/components   ║
 ╚═════════╝  GET  ╚════════════════╝       │ (с Mustache.js)  │<─+──>║   app/data         ║
             /                              └─────────┬────────┘  │    ╚════════════════╝
                                                      │ 2. Рендеринг  │ 3. Загрузка ассетов
                                            ┌─────────▼────────┐    │ (AssetLoader)
                                            │ Готовый HTML+CSS │<───+
                                            └─────────┬────────┘
                                                      │ 4. Ответ клиенту
                                            ┌─────────▼────────┐
 ╔═════════╗       ╔════════════════╗       │   HTTP Response  │
 ║ Browser ║<──────║  RequestHandler  ║<──────┤ (HTML страница)  │
 ╚═════════╝       ╚════════════════╝       └──────────────────┘
```

#### Обработка Декларативного Действия (`POST /action/...`)

```ascii
                                                             ┌──────────────────┐
                                                             │   manifest.js    │
 ╔═════════╗       ╔════════════════╗       ┌───────────┬───>│(route: 'action', │
 ║ Browser ║──────>║ engine-client.js ║ POST->║ RequestHandler  ├─>│  'manipulate')   │ 1.
 ╚═════════╝       ╚════════════════╝       └─────┬─────┬───┘  └──────────────────┘
   (Клик)                                        │     │
                                                 │     │ 2. Создание контекста
                                                 │     └──────────┐
                                                 │      ┌─────────▼─────────┐
                                                 └─────>│   DataManipulator │
                                               3. Вызов  └─────────┬─────────┘
                                                  манипулятора     │ 4. Изменение данных
                                                                   │    в контексте
                                                         ┌─────────▼─────────┐
 ╔═════════╗       ╔════════════════╗       ┌───────────┐│   DataManager     │
 ║ Browser ║<──────║ engine-client.js ║<──────┤ HTML-фрагмент ├─+──>│ (с FormulaEngine) │
 ╚═════════╝       ╚════════════════╝  HTML   └───────────┘ │ 8. │ └─────────┬─────────┘
   8. Умное                              (ответ)          │    │           │ 5. Вычисление
   обновление                                             │    │              (computed)
   DOM                                                    │    │           ┌─────────▼─────────┐
                                                          │    └───────────┤  Сохранение в JSON  │
                                                          │                ╚═══════════════════╝
                                                          │ 6. Рендеринг обновленного
                                                          │    компонента (Renderer)
                                                          └─────────────────┘
```

---

## 🛠️ Как это использовать

### 1. Установка и Запуск

Клонируйте репозиторий. **Serverokey** не требует `npm install`.
```bash
git clone https://github.com/Xzdes/serverokey.git && cd serverokey
node engine.js
```
Сервер запустится на `http://localhost:3000`.

### 2. Рабочий процесс для LLM (Декларативный путь)

**Задача:** "Сделай так, чтобы при очистке чека скидка тоже сбрасывалась до 10%."

LLM не пишет JS-код. Она описывает последовательность действий в `manifest.js`, используя `steps`.

```javascript
// manifest.js
// ...
'POST /action/clearReceipt': {
  type: 'action',
  // handler больше не нужен, используем steps
  steps: [
    // Шаг 1: Очищаем массив товаров
    { "set": "receipt.items", "to": "[]" },
    
    // Шаг 2: Сбрасываем процент скидки
    { "set": "receipt.discountPercent", "to": "10" }
  ],
  reads: ['receipt'],
  writes: ['receipt'],
  update: 'receipt'
}
// ...
```

**Результат:** Задача решена **без единой строчки императивного JS-кода**. LLM описала сценарий, а движок его выполнил. Это быстрее, безопаснее и полностью соответствует философии Serverokey.

---

## 💡 Ключевые концепции API в `manifest.js`

### `globals`
Опциональная секция для определения данных, доступных во всех компонентах.

```javascript
globals: {
  appName: "Мое Приложение",
  // Делает источник данных 'user' доступным глобально
  injectData: ['user'] 
}
```

### `data`
Описывает источники данных и их вычисляемые поля.

```javascript
data: {
  receipt: {
    initialState: { items: [], total: '0.00' },
    // Поля, которые вычисляются автоматически при каждом изменении `receipt`
    computed: [
      {
        "target": "total",                // Какое поле вычислить
        "formula": "sum(items, 'price')", // Как его вычислить (встроенная функция)
        "format": "toFixed(2)"            // Как отформатировать
      },
      {
        "target": "discount",
        "formula": "total * (discountPercent / 100)" // Простое JS-выражение
      }
    ]
  }
}
```

### `components`
Описывает компоненты и их стили.
```javascript
components: {
  receipt: {
    template: 'receipt.html',   // Шаблон компонента
    style: 'receipt.css'        // Связанный файл стилей
  }
}
```

### `routes`
Связывает URL с действиями. `type: 'action'` может иметь одно из трех полей для выполнения логики (в порядке приоритета):

1.  `steps`: **(Самый гибкий)** Массив последовательных шагов для выполнения сложной логики.
2.  `manipulate`: **(Предпочтительно для простых CRUD)** Декларативное описание одной операции с данными (`push`, `removeFirstWhere` или кастомной).
3.  `handler`: **(Запасной выход)** Имя JS-файла для очень сложной, нешаблонной логики.

#### Кастомные операции
Вы можете расширять возможности `manipulate`, создавая свои собственные операции в папке `app/operations/`.

**Пример:** `app/operations/applyCoupon.js`
```javascript
module.exports = (context, args) => {
  if (args.couponCode === 'SALE15') {
    context.receipt.discountPercent = 15;
  }
};
```
**Использование в `manifest.js`:**
```javascript
'POST /action/applyCoupon': {
  type: 'action',
  manipulate: {
    operation: 'custom:applyCoupon', // Вызов кастомной операции
    args: { couponCode: 'body.coupon_code' }
  },
  // ...
}
```

---

## 템 Шаблоны и Директивы

Движок использует **Mustache.js** для рендеринга, поэтому LLM может использовать весь стандартный синтаксис (`{{variable}}`, `{{#array}}...`, `{{^variable}}...`). В дополнение, Serverokey предоставляет директиву `atom-if` для управления видимостью элементов.

```html
<!-- Этот блок будет показан, только если в массиве receipt.items есть элементы -->
<ul atom-if="receipt.items.length > 0">
    ...
</ul>

<!-- Этот блок будет показан, только если в массиве receipt.items НЕТ элементов -->
<div atom-if="!receipt.items.length">
    Чек пуст
</div>
```

---

## 🔮 Будущие улучшения

*   [ ] **Валидатор Манифеста:** Отдельный скрипт (`node validate.js`) для проверки `manifest.js` на логические ошибки.
*   [ ] **Декларативные HTTP-запросы:** Возможность для `action` декларативно выполнять GET/POST запросы к внешним API.
*   [ ] **Горячая перезагрузка (Hot-reloading):** Автоматический перезапуск сервера при изменении `manifest.js` или компонентов.
*   [ ] **Расширение `FormulaEngine`:** Добавление новых встроенных функций (`average`, `find`, etc.) для еще более мощных вычислений.

---

Этот проект — эксперимент в области взаимодействия человека и машины, направленный на создание надежных и предсказуемых программных систем. Буду рад вашим идеям и вкладу!

**Xzdes**